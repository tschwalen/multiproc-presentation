# -*- coding: utf-8 -*-
"""GFSMP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15iz8y_7_NtCRMoLG25HMl9-HUsBxvxkd
"""

import math
from PIL import Image as Img

import multiprocessing as mp

CANVAS_WIDTH = 800
CANVAS_HEIGHT = 800
VIEWPORT_WIDTH = 1
VIEWPORT_HEIGHT = 1
VIEWPORT_DISTANCE = 1

BG_COLOR = (0, 0, 0)

inf = float("inf")

Spheres = [
    {
        "center" : (0, -1, 3),
        "radius" : 1, 
        "color" : (255, 0, 0),
    },
    {
        "center" : (2, 0, 4),
        "radius" : 1,
        "color" : (0, 0, 255),
    },
    {
        "center" : (-2, 0, 4),
        "radius" : 1,
        "color" : (0, 255, 0),
    },
    {
        "color" : (255, 255, 0) ,
        "center" : (0, -5001, 0),
        "radius" : 5000
    },
    {
        "center" : (0, 5, 40),
        "radius" : 4, 
        "color" : (255, 160, 0),
    },
    {
        "center" : (20, 5, 80),
        "radius" : 4, 
        "color" : (255, 160, 200),
    },
    {
        "center" : (-20, 5, 120),
        "radius" : 4, 
        "color" : (255, 160, 100),
    }
]

Lights = [
    {
        "type" : "ambient",
        "intensity" : 0.2
    },
    {
        "type" : "point",
        "intensity" : 0.6,
        "position" : (2, 1, 0)
    },
    {
        "type" : "directional",
        "intensity" : 0.2,
        "direction" : (1, 4, 4)
    },
]

def putPixel(canvas, x, y, color):
    #print(color)
    x = (CANVAS_WIDTH / 2) + x
    y = CANVAS_HEIGHT - ((CANVAS_HEIGHT / 2) + y)
    x = int(x)
    y = int(y)
    color = (int(color[0]), int(color[1]), int(color[2]))
    #print( (x, y, color))
    if 0 <= x < CANVAS_WIDTH and 0 <= y < CANVAS_HEIGHT:
      canvas.putpixel( (x, y), color)

def renderPixel(args):
    x, y = args
    O = (0, 0, 0)
    D = canvasToViewport(x, y)
    color = traceRay(O, D, 1, inf)
    return x, y, color

def renderMP(canvas):
    pool = mp.Pool( 6 )

    work_queue = ( (x, y ) for x in range(-CANVAS_WIDTH//2, CANVAS_WIDTH//2) for y in range(-CANVAS_HEIGHT//2, CANVAS_HEIGHT//2))
    buffer = pool.map(renderPixel, work_queue)
    for x, y, color in buffer:
        putPixel(canvas, x, y, color)

def render(canvas):
    O = (0, 0, 0)
    for x in range(-CANVAS_WIDTH//2, CANVAS_WIDTH//2):
        for y in range(-CANVAS_HEIGHT//2, CANVAS_HEIGHT//2):
            D = canvasToViewport(x, y)
            color = traceRay(O, D, 1, inf)
            putPixel(canvas, x, y, color)

def canvasToViewport(x, y):
    return (x * VIEWPORT_WIDTH /  CANVAS_WIDTH, y * VIEWPORT_HEIGHT / CANVAS_HEIGHT, VIEWPORT_DISTANCE)

def traceRay(O, D, t_min, t_max):
    closest_t = inf
    closest_sphere = None
    for sphere in Spheres:
        t1, t2 = intersectRaySphere(O, D, sphere)
        if (t_min <= t1 and t1 <= t_max) and t1 < closest_t:
            closest_t = t1
            closest_sphere = sphere
        if (t_min <= t2 and t2 <= t_max) and t2 < closest_t:
            closest_t = t2
            closest_sphere = sphere

    if closest_sphere == None:
       return BG_COLOR

    P = vector_add(O, scalar_vector_mul(closest_t, D))
    N = vector_subtract(P, closest_sphere["center"])
    N = vector_scalar_div(N, vector_length(N))
    return scalar_vector_mul( computeLighting(P, N), closest_sphere["color"] )

def vector_scalar_div(v, s):
    return tuple( i / s for i in v)

def scalar_vector_mul(s, v):
    # print("s : %s" % s)
    # print("v : " + str(v))
    return tuple( s * i for i in v)

def vector_add(v1, v2):
    return tuple( i + j for i, j in zip(v1, v2))

def vector_subtract(v1, v2):
    return tuple( i - j for i, j in zip(v1, v2))

def vector_length(v):
    return math.sqrt(sum( i ** 2 for i in v))

def dot(v1, v2):
    return sum( i * j for i, j in zip(v1, v2))

def intersectRaySphere(O, D, sphere):
    r = sphere["radius"]
    C = sphere["center"]
    CO = vector_subtract(O, C)

    a = dot(D, D)
    b = 2 * dot(CO, D)
    c = dot(CO, CO) - r * r

    discriminant = b * b - 4 * a * c
    if discriminant < 0:
        return inf, inf

    t1 = (-b + math.sqrt(discriminant)) / (2*a)
    t2 = (-b - math.sqrt(discriminant)) / (2*a)
    return t1, t2

def computeLighting(P, N):
    i = 0.0
    
    for light in Lights:
        if light["type"] == "ambient":
            i += light["intensity"]
        else:
            if light["type"] == "point":
                L = vector_subtract(light["position"], P)
            else:
                L = light["direction"]
            
            n_dot_l = dot(N, L)
            if n_dot_l > 0:
                i += light["intensity"] * n_dot_l / (vector_length(N) * vector_length(L))

    return i

def main():
    import time

    start = time.time()
    myCanvas = Img.new('RGB', ( CANVAS_HEIGHT, CANVAS_WIDTH))
    renderMP(myCanvas)
    myCanvas.save('canvas1.png')
    end = time.time()
    print(end - start)

    # start = time.time()
    # myCanvas = Img.new('RGB', ( CANVAS_HEIGHT, CANVAS_WIDTH))
    # render(myCanvas)
    # myCanvas.save('canvas2.png')
    # end = time.time()
    # print(end - start)

if __name__ == "__main__":
    main()
